substitutions:
  device_name: "h-esp-pzem-power-01"
  friendly_name: "Power Monitor 01"
  device_comment: "Dual Phase Energy Monitor"
  version: "26.01.02.7"
  
  # Pin definitions for XIAO ESP32-C3
  # Physically: D6=TX(GPIO21), D7=RX(GPIO20)
  uart_tx_pin: GPIO21
  uart_rx_pin: GPIO20
  update_interval: "10s"
  
  # Modbus addresses assigned to modules
  addr_phase_a: "1"
  addr_phase_b: "2"

esphome:
  name: ${device_name}
  comment: ${device_comment}
  on_boot:
    priority: -10
    then:
      - delay: 3s
      - lambda: |-
          id(v_l1).publish_state(0);
          id(p_l1).publish_state(0);
          id(v_l2).publish_state(0);
          id(p_l2).publish_state(0);
          id(total_power).publish_state(0);
          ESP_LOGI("main", "Boot sequence completed, PZEM monitoring started.");

esp32:
  board: seeed_xiao_esp32c3
  framework:
    type: esp-idf

# --- Connectivity ---
api:
  encryption:
    key: !secret encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: ${device_name}.local
  ap:
    ssid: "${device_name}_ap"
    password: !secret ssid_password

web_server:
  port: 80

logger:
  level: INFO

captive_portal:

# --- Communication Bus ---
uart:
  id: uart_bus
  tx_pin: ${uart_tx_pin}
  rx_pin: ${uart_rx_pin}
  baud_rate: 9600
  stop_bits: 1
  rx_buffer_size: 512

# --- PZEM Watchdog ---
interval:
  - interval: 1min
    then:
      - lambda: |-
          static int failure_min = 0;
          static int uart_reset_count = 0;

          // Condition: no data (voltage < 100V or NaN)
          if (std::isnan(id(v_l1).state) || id(v_l1).state < 100.0) {
            failure_min++;
            ESP_LOGW("watchdog", "PZEM failure detected. Minutes: %d", failure_min);
          } else {
            failure_min = 0;
            uart_reset_count = 0;
            return;
          }

          // Stage 1: After 2 minutes, try a "soft" UART restart
          if (failure_min == 2) {
            ESP_LOGE("watchdog", "Attempting soft UART reset...");
            // Clearing UART buffers
            id(uart_bus).flush(); 
            // Reinitializing UART via built-in ESPHome method
            id(uart_bus).setup(); 
            uart_reset_count++;
          }

          // Step 2: If UART reset does not help for another 3 minutes (5 total)
          // Or if we have already exhausted the UART reset attempt limit
          if (failure_min >= 5) {
            ESP_LOGE("watchdog", "Soft resets failed. Hardware rebooting ESP...");
            App.reboot();
          }

# --- Visual/Diagnostic Sensors ---
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP Address"
  - platform: template
    name: "Uptime"
    id: uptime_human
    icon: mdi:clock-start

sensor:
  # --- PHASE L1 (Address 1) ---
  - platform: pzemac
    id: pzem_l1
    address: ${addr_phase_a}
    update_interval: ${update_interval}
    voltage:
      name: "${friendly_name} L1 Voltage"
      id: v_l1
      filters:
        - lambda: "return (x > 300.0) ? NAN : x;"
        - timeout:
            timeout: 25s
            value: 0
    power:
      name: "${friendly_name} L1 Power"
      id: p_l1
      filters:
        - lambda: "return (x > 25000.0) ? NAN : x;"
        - timeout:
            timeout: 25s
            value: 0

    power_factor:
      name: "L1 Power Factor"
      id: pf_l1
    
    frequency:
      name: "${friendly_name} L1 Frequency"
      id: f_l1
      filters:
        - timeout:
            timeout: 25s
            value: 0

    energy:
      name: "${friendly_name} L1 Energy"
      id: e_l1
      unit_of_measurement: "kWh"  
      accuracy_decimals: 3        
      device_class: energy
      state_class: total_increasing
      filters:
        - lambda: "return (x > 1000000.0) ? NAN : x;" 
        - multiply: 0.001

  # --- PHASE L2 (Address 2) ---
  - platform: pzemac
    id: pzem_l2
    address: ${addr_phase_b}
    update_interval: ${update_interval}
    voltage:
      name: "${friendly_name} L2 Voltage"
      id: v_l2
      filters:
        - lambda: "return (x > 300.0) ? NAN : x;"
        - timeout:
            timeout: 25s
            value: 0
    power:
      name: "${friendly_name} L2 Power"
      id: p_l2
      filters:
        - lambda: "return (x > 25000.0) ? NAN : x;"
        - timeout:
            timeout: 25s
            value: 0

    power_factor:
      name: "L2 Power Factor"
      id: pf_l2

    frequency:
      name: "${friendly_name} L2 Frequency"
      id: f_l2
      filters:
        - timeout:
            timeout: 25s
            value: 0

    energy:
      name: "${friendly_name} L2 Energy"
      id: e_l2
      unit_of_measurement: "kWh"  
      accuracy_decimals: 3        
      device_class: energy
      state_class: total_increasing
      filters:
        - lambda: "return (x > 1000000.0) ? NAN : x;" 
        - multiply: 0.001

  # --- CALCULATED METRICS ---
  - platform: template
    name: "${friendly_name} Total Power"
    unit_of_measurement: "W"
    id: total_power
    state_class: measurement
    device_class: power
    lambda: |-
      float p1 = id(p_l1).state;
      float p2 = id(p_l2).state;
      if (std::isnan(p1)) p1 = 0.0f;
      if (std::isnan(p2)) p2 = 0.0f;
      return p1 + p2;
    update_interval: ${update_interval}

  - platform: internal_temperature
    name: "${friendly_name} Temperature"
    unit_of_measurement: "Â°C"
    update_interval: 60s

  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"
 
  - platform: uptime
    id: uptime_sensor
    update_interval: 60s
    internal: true
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(x);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              return ((days ? to_string(days) + "d " : "") +
                     (hours ? to_string(hours) + "h " : "") +
                     (minutes ? to_string(minutes) + "m " : "")).c_str();

binary_sensor:
  - platform: template
    name: "${friendly_name} PZEM Status"
    device_class: connectivity
    lambda: |-
      return !std::isnan(id(v_l1).state);

# --- Control Buttons ---
button:
  - platform: template
    name: "${friendly_name} L1 Reset Energy"
    icon: "mdi:refresh"
    on_press:
      - pzemac.reset_energy:
          id: pzem_l1
          
  - platform: template
    name: "${friendly_name} L2 Reset Energy"
    icon: "mdi:refresh"
    on_press:
      - pzemac.reset_energy:
          id: pzem_l2

  - platform: restart
    name: "ESP Reboot"
    icon: mdi:power-cycle
    entity_category: "diagnostic"

  - platform: template
    name: "Debug Soft Reset UART"
    on_press:
      - lambda: |-
          id(uart_bus).flush();
          id(uart_bus).setup();
          ESP_LOGI("uart", "Manual UART soft-reset performed");

